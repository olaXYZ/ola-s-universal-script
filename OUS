local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
	Name = "Ola and ZCayxx's Universal script",
	Icon = 0,
	LoadingTitle = "ðŸ˜ˆ BEST UNIVERSAL SCRIPT ðŸ˜ˆ",
	LoadingSubtitle = "by Ola and ZCayxx",
	ShowText = "DiddyBlud",
	Theme = "Default",
	ToggleUIKeybind = "Z",
	DisableRayfieldPrompts = false,
	DisableBuildWarnings = false,
	ConfigurationSaving = {
		Enabled = true,
		FolderName = nil,
		FileName = "Ola Hub"
	},
	Discord = {
		Enabled = true,
		Invite = "S8j8GRX7dm",
		RememberJoins = false
	},
	KeySystem = true, -- Set this to true to use our key system
	KeySettings = {
		Title = "discord.gg/S8j8GRX7dm",
		Subtitle = "Key System",
		Note = "to get the key, you must join the discord server", -- Use this to tell the user how to get a key
		FileName = "OlaZcayxxKey", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
		SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
		GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
		Key = {"JClodkV0DSt64fC8jSq17klcUc46c889sZw6"}} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
})

local Tab = Window:CreateTab("Universal", 4483362458) -- Title, Image

-- Noclip variables
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local noclip = false

-- Function to toggle noclip
local function setNoclip(enabled)
	noclip = enabled

	if character then
		for _, part in pairs(character:GetDescendants()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
				part.CanCollide = not enabled
			end
		end
	end
end

-- Update noclip on every frame for respawning parts
RunService.Stepped:Connect(function()
	if noclip and character then
		for _, part in pairs(character:GetDescendants()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
				part.CanCollide = false
			end
		end
	end
end)

-- Reapply noclip on respawn
player.CharacterAdded:Connect(function(char)
	character = char
	if noclip then
		for _, part in pairs(character:GetDescendants()) do
			if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
				part.CanCollide = false
			end
		end
	end
end)


local Slider = Tab:CreateSlider({
	Name = "WalkSpeed",
	Range = {16, 500},
	Increment = 1,
	Suffix = "WalkSpeed",
	CurrentValue = 16,
	Flag = "Slider1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		if game.Players.LocalPlayer.Character.Humanoid then
			game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Value
		end
	end,
})

local Slider2 = Tab:CreateSlider({
	Name = "JumpPower",
	Range = {0, 500},
	Increment = 10,
	Suffix = "JumpPower",
	CurrentValue = 50,
	Flag = "Slider2", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
	Callback = function(Value)
		if game.Players.LocalPlayer.Character.Humanoid then
			game.Players.LocalPlayer.Character.Humanoid.JumpPower = Value
		end
	end,
})

-- Rayfield toggle for noclip
Tab:CreateToggle({
	Name = "Noclip",
	CurrentValue = false,
	Flag = "NoclipToggle",
	Callback = function(Value)
		-- Value = true -> enable noclip
		-- Value = false -> disable noclip
		setNoclip(Value)
	end,
})


local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local infJumpEnabled = false

-- Input listener for jumps
UserInputService.JumpRequest:Connect(function()
	if infJumpEnabled then
		humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
	end
end)

-- Toggle for your UI
Tab:CreateToggle({
	Name = "Infinite jumps",
	CurrentValue = false,
	Flag = "InfJumpToggle",
	Callback = function(Value)
		infJumpEnabled = Value
	end,
})
























local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local cam = Workspace.CurrentCamera

-- Variable to store the sphere
local sphere = nil

-- Default settings
local freecamEnabled = false
local speed = 50
local boostMultiplier = 2
local keys = {
	W = false, A = false, S = false, D = false,
	Space = false, LeftControl = false, RightControl = false,
	LeftShift = false, RightShift = false
}
local sensitivity = 0.2

-- Track key states
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	if keys[input.KeyCode.Name] ~= nil then
		keys[input.KeyCode.Name] = true
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if keys[input.KeyCode.Name] ~= nil then
		keys[input.KeyCode.Name] = false
	end
end)

-- Track mouse movement (for camera rotation)
local mouseDelta = Vector2.new(0, 0)
UserInputService.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement then
		mouseDelta += Vector2.new(input.Delta.X, input.Delta.Y)
	end
end)

-- Function to create the sphere
local function createSphere()
	sphere = Instance.new("Part")
	sphere.Size = Vector3.new(2, 2, 2)  -- Size of the sphere
	sphere.Shape = Enum.PartType.Ball
	sphere.Transparency = 0.5
	sphere.Anchored = true
	sphere.CanCollide = false
	sphere.Position = cam.CFrame.Position  -- Position it at the camera's location
	sphere.Parent = Workspace
end

-- Function to destroy the sphere
local function destroySphere()
	if sphere then
		sphere:Destroy()
		sphere = nil
	end
end

-- Function to toggle freecam
local function toggleFreecam(enabled)
	freecamEnabled = enabled
	if enabled then
		createSphere()
		-- Set camera to scriptable (no automatic following of the character)
		cam.CameraType = Enum.CameraType.Scriptable
	else
		destroySphere()
		-- Return camera to normal
		cam.CameraType = Enum.CameraType.Custom
	end
end

-- Freecam update loop (move the sphere and update camera)
RunService.RenderStepped:Connect(function(delta)
	if freecamEnabled then
		-- Movement controls (WASD, Space, Ctrl, Shift)
		local moveVec = Vector3.new()
		if keys.W then moveVec += cam.CFrame.LookVector end
		if keys.S then moveVec -= cam.CFrame.LookVector end
		if keys.A then moveVec -= cam.CFrame.RightVector end
		if keys.D then moveVec += cam.CFrame.RightVector end

		-- Vertical movement (Space for up, Ctrl for down)
		local up = 0
		if keys.Space then up += 1 end
		if keys.LeftControl or keys.RightControl then up -= 1 end
		moveVec += Vector3.new(0, up, 0)

		-- Apply movement speed (boost with Shift)
		if moveVec.Magnitude > 0 then
			local finalSpeed = speed
			if keys.LeftShift or keys.RightShift then
				finalSpeed *= boostMultiplier
			end
			moveVec = moveVec.Unit * finalSpeed * delta

			-- Move the sphere based on input (not the camera)
			sphere.CFrame = sphere.CFrame + moveVec
		end

		-- Camera rotation (yaw and pitch based on mouse input)
		local yaw = -mouseDelta.X * sensitivity * 0.01
		local pitch = -mouseDelta.Y * sensitivity * 0.01

		-- Clamp pitch to prevent flipping upside down
		pitch = math.clamp(pitch, -math.pi/2, math.pi/2)

		-- Reset mouseDelta after applying movement
		mouseDelta = Vector2.new(0, 0)

		-- Set the camera's CFrame to follow the sphere
		local rotation = CFrame.Angles(pitch, yaw, 0)
		cam.CFrame = sphere.CFrame * rotation
	end
end)

-- Toggle freecam when the player activates it
Tab:CreateToggle({
	Name = "Freecam",
	CurrentValue = false,
	Flag = "FreecamToggle",
	Callback = function(Value)
		toggleFreecam(Value)  -- Toggle freecam on or off
	end,
})




























-- ESP variables
local ESPEnabled = false
local ESPHighlights = {}
local ESPBillboards = {}

local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- Function to create a BillboardGui for a player
local function createBillboard(plr)
	if not plr.Character then return end
	local head = plr.Character:FindFirstChild("Head")
	if not head then return end

	local billboard = Instance.new("BillboardGui")
	billboard.Name = "ESPBillboard"
	billboard.Adornee = head
	billboard.Size = UDim2.new(0, 100, 0, 25)
	billboard.StudsOffset = Vector3.new(0, 2, 0)
	billboard.AlwaysOnTop = true

	local label = Instance.new("TextLabel")
	label.Parent = billboard
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.TextColor3 = Color3.fromRGB(255, 0, 0)
	label.TextStrokeTransparency = 0
	label.TextStrokeColor3 = Color3.fromRGB(255, 255, 255)
	label.TextScaled = true
	label.Text = plr.DisplayName
	label.Font = Enum.Font.SourceSansBold

	billboard.Parent = head
	ESPBillboards[plr] = billboard
end

-- Function to create Highlight for a player
local function createHighlight(plr)
	if not plr.Character then return end
	if ESPHighlights[plr] then ESPHighlights[plr]:Destroy() end

	local highlight = Instance.new("Highlight")
	highlight.Adornee = plr.Character
	highlight.FillColor = Color3.fromRGB(255, 0, 0)
	highlight.FillTransparency = 0.5
	highlight.OutlineTransparency = 0
	highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
	highlight.Parent = plr.Character
	ESPHighlights[plr] = highlight
end

-- Apply ESP to a player
local function applyESP(plr)
	if plr == player then return end  -- skip local player

	local function addESPToCharacter(char)
		task.wait(0.1) -- wait for character parts
		if ESPEnabled and char and char.Parent then
			createHighlight(plr)
			createBillboard(plr)
		end
	end

	-- Initial character
	if plr.Character then
		addESPToCharacter(plr.Character)
	end

	-- Reapply on respawn
	plr.CharacterAdded:Connect(function(char)
		addESPToCharacter(char)
	end)
end

-- Toggle ESP on/off
local function setESP(enabled)
	ESPEnabled = enabled

	-- Remove all ESP when toggled off
	if not enabled then
		for plr, highlight in pairs(ESPHighlights) do
			if highlight then highlight:Destroy() end
		end
		ESPHighlights = {}

		for plr, billboard in pairs(ESPBillboards) do
			if billboard then billboard:Destroy() end
		end
		ESPBillboards = {}
	else
		for _, plr in pairs(Players:GetPlayers()) do
			applyESP(plr)
		end
	end
end

-- Remove ESP when a player leaves
Players.PlayerRemoving:Connect(function(plr)
	if ESPHighlights[plr] then
		ESPHighlights[plr]:Destroy()
		ESPHighlights[plr] = nil
	end
	if ESPBillboards[plr] then
		ESPBillboards[plr]:Destroy()
		ESPBillboards[plr] = nil
	end
end)

-- Rayfield toggle for ESP
-- Rayfield toggle for ESP
Tab:CreateToggle({
	Name = "ESP",
	CurrentValue = false,
	Flag = "ESPToggle",
	Callback = function(Value)
		setESP(Value)
	end,
})

-- Ensure ESP applies to players who join after toggle is on
game:GetService("Players").PlayerAdded:Connect(function(plr)
	-- Only apply if ESP is enabled
	if ESPEnabled and plr ~= player then
		applyESP(plr)
	end
end)












local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local cam = Workspace.CurrentCamera

local desyncEnabled = false
local ghost = nil
local moveSpeed = 75
local hoverHeight = 0 -- height above ground

local keys = {W=false,A=false,S=false,D=false}

-- Input tracking
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	if keys[input.KeyCode.Name] ~= nil then keys[input.KeyCode.Name] = true end
end)
UserInputService.InputEnded:Connect(function(input)
	if keys[input.KeyCode.Name] ~= nil then keys[input.KeyCode.Name] = false end
end)

-- Create full ghost
local function createGhost()
	if ghost then ghost:Destroy() end

	ghost = Instance.new("Model")
	ghost.Name = "GhostCharacter"

	for _, part in pairs(character:GetDescendants()) do
		if part:IsA("BasePart") then
			local newPart = part:Clone()
			newPart.Transparency = 0.5
			newPart.CanCollide = false
			newPart.Anchored = true -- we move it manually
			newPart.Parent = ghost
		end
	end

	local primary = ghost:FindFirstChild("HumanoidRootPart") or ghost:FindFirstChildWhichIsA("BasePart")
	ghost.PrimaryPart = primary
	ghost:SetPrimaryPartCFrame(hrp.CFrame)
	ghost.Parent = workspace
end

local function removeGhost()
	if ghost then
		ghost:Destroy()
		ghost = nil
	end
end

-- Raycast to ground
local function getGroundY(position)
	local rayOrigin = position + Vector3.new(0, 5, 0)
	local rayDirection = Vector3.new(0, -100, 0)
	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {ghost}
	params.FilterType = Enum.RaycastFilterType.Blacklist

	local result = Workspace:Raycast(rayOrigin, rayDirection, params)
	if result then
		return result.Position.Y + hoverHeight
	else
		return position.Y
	end
end

-- Movement
RunService.RenderStepped:Connect(function(delta)
	if desyncEnabled and ghost and ghost.PrimaryPart then
		local moveVec = Vector3.new()
		if keys.W then moveVec += cam.CFrame.LookVector end
		if keys.S then moveVec -= cam.CFrame.LookVector end
		if keys.A then moveVec -= cam.CFrame.RightVector end
		if keys.D then moveVec += cam.CFrame.RightVector end
		moveVec = Vector3.new(moveVec.X, 0, moveVec.Z)

		if moveVec.Magnitude > 0 then
			moveVec = moveVec.Unit * moveSpeed * delta
			local newPos = ghost.PrimaryPart.Position + moveVec
			newPos = Vector3.new(newPos.X, getGroundY(newPos), newPos.Z)
			ghost:SetPrimaryPartCFrame(CFrame.new(newPos))
		else
			local pos = ghost.PrimaryPart.Position
			ghost:SetPrimaryPartCFrame(CFrame.new(Vector3.new(pos.X, getGroundY(pos), pos.Z)))
		end
	end
end)

-- Toggle
Tab:CreateToggle({
	Name = "Desync character",
	CurrentValue = false,
	Flag = "DesyncToggle",
	Callback = function(Value)
		desyncEnabled = Value
		if Value then
			createGhost()
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Anchored = true
				end
			end
			-- Free camera attached to ghost
			cam.CameraSubject = ghost.PrimaryPart
			cam.CameraType = Enum.CameraType.Custom
		else
			removeGhost()
			for _, part in pairs(character:GetDescendants()) do
				if part:IsA("BasePart") then
					part.Anchored = false
				end
			end
			cam.CameraSubject = character:FindFirstChild("Humanoid") or hrp
			cam.CameraType = Enum.CameraType.Custom
		end
	end,
})















local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local mouse = player:GetMouse()

local clickTPEnabled = false

-- Function to teleport player to mouse position
local function onClickTeleport()
	if not clickTPEnabled then return end
	if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
	local hrp = player.Character.HumanoidRootPart
	local targetPos = mouse.Hit.Position
	hrp.CFrame = CFrame.new(targetPos + Vector3.new(0, 3, 0)) -- add a small Y offset so you don't clip the floor
end

-- Detect Ctrl + Left Mouse Button
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end
	if input.UserInputType == Enum.UserInputType.MouseButton1 and UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
		onClickTeleport()
	end
end)

-- Rayfield toggle
Tab:CreateToggle({
	Name = "Click Teleport (ctrl + mb1)",
	CurrentValue = false,
	Flag = "ClickTpToggle",
	Callback = function(Value)
		clickTPEnabled = Value
	end,
})



local Players = game:GetService("Players")
local player = Players.LocalPlayer

local Players = game:GetService("Players")
local player = Players.LocalPlayer

local Input = Tab:CreateInput({
	Name = "Teleport to Player",
	CurrentValue = "",
	PlaceholderText = "Enter username or display name",
	RemoveTextAfterFocusLost = false,
	Flag = "TeleportInput",
	Callback = function(Text)
		-- Exit if textbox is empty
		if Text == "" then
			return
		end

		local Players = game:GetService("Players")
		local player = Players.LocalPlayer
		local targetText = Text:lower() -- case insensitive
		local targetPlayer = nil

		-- First, try to find exact match by username or display name
		for _, plr in pairs(Players:GetPlayers()) do
			if plr ~= player then
				if plr.Name:lower() == targetText or plr.DisplayName:lower() == targetText then
					targetPlayer = plr
					break
				end
			end
		end

		-- If no exact match, try partial match
		if not targetPlayer then
			for _, plr in pairs(Players:GetPlayers()) do
				if plr ~= player then
					if string.find(plr.Name:lower(), targetText) or string.find(plr.DisplayName:lower(), targetText) then
						targetPlayer = plr
						break
					end
				end
			end
		end

		-- Teleport if we found someone
		if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
			player.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
		else
			warn("Player not found or no character loaded!")
		end
	end,
})





local Button = Tab:CreateButton({
	Name = "Invisibility GUI",
	Callback = function()
		Rayfield:Notify({
			Title = "Info",
			Content = "Press G to toggle invisibility ON / OFF",
			Duration = 6.5,
			Image = 16412844205,
		})
		loadstring(game:HttpGet('https://pastebin.com/raw/3Rnd9rHf'))()
	end,
})

local Tab3 = Window:CreateTab("Games and others", 4483362458) -- Title, Image







local Tab2 = Window:CreateTab("Debug", 4483362458) -- Title, Image

local Button = Tab2:CreateButton({
	Name = "Dex Explorer",
	Callback = function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/BigBoyTimme/New.Loadstring.Scripts/refs/heads/main/Dex.Explorer"))()
	end,
})

local Button = Tab2:CreateButton({
	Name = "Reset (HEALTH = 0)",
	Callback = function()
		game.Players.LocalPlayer.Character.Humanoid.Health = 0
	end,
})


